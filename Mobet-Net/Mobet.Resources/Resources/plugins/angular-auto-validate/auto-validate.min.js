/*
 * angular-auto-validate - v1.18.10 - 2015-08-03
 * https://github.com/jonsamwell/angular-auto-validate
 * Copyright (c) 2015 Jon Samwell (http://www.jonsamwell.com)
 */
!(function (angular) { angular.module("angular.auto.validate", []) }(angular)); (function (angular) { angular.module("angular.auto.validate").provider("validator", [function () { var elementStateModifiers = {}, enableValidElementStyling = true, enableInvalidElementStyling = true, validationEnabled = true, toBoolean = function (value) { var v; if (value && value.length !== 0) { v = value.toLowerCase(); value = !(v === "f" || v === "0" || v === "false") } else { value = false } return value }, getAttributeValue = function (el, attrName) { var val; if (el !== undefined) { val = el.attr(attrName) || el.attr("data-" + attrName) } return val }, attributeExists = function (el, attrName) { var exists; if (el !== undefined) { exists = el.attr(attrName) !== undefined || el.attr("data-" + attrName) !== undefined } return exists }, getBooleanAttributeValue = function (el, attrName) { return toBoolean(getAttributeValue(el, attrName)) }, validElementStylingEnabled = function (el) { return enableValidElementStyling && !getBooleanAttributeValue(el, "disable-valid-styling") }, invalidElementStylingEnabled = function (el) { return enableInvalidElementStyling && !getBooleanAttributeValue(el, "disable-invalid-styling") }; this.enable = function (isEnabled) { validationEnabled = isEnabled }; this.isEnabled = function () { return validationEnabled }; this.setDefaultElementModifier = function (key) { if (elementStateModifiers[key] === undefined) { throw new Error("Element modifier not registered: " + key) } this.defaultElementModifier = key }; this.registerDomModifier = function (key, modifier) { elementStateModifiers[key] = modifier }; this.setErrorMessageResolver = function (resolver) { this.errorMessageResolver = resolver }; this.getErrorMessage = function (errorKey, el) { var defer; if (this.errorMessageResolver === undefined) { throw new Error("Please set an error message resolver via the setErrorMessageResolver function before attempting to resolve an error message.") } if (attributeExists(el, "disable-validation-message")) { defer = angular.injector(["ng"]).get("$q").defer(); defer.resolve(""); return defer.promise } else { return this.errorMessageResolver(errorKey, el) } }; this.setValidElementStyling = function (enabled) { enableValidElementStyling = enabled }; this.setInvalidElementStyling = function (enabled) { enableInvalidElementStyling = enabled }; this.getDomModifier = function (el) { var modifierKey = (el !== undefined ? el.attr("element-modifier") : this.defaultElementModifier) || (el !== undefined ? el.attr("data-element-modifier") : this.defaultElementModifier) || this.defaultElementModifier; if (modifierKey === undefined) { throw new Error("Please set a default dom modifier via the setDefaultElementModifier method on the validator class.") } return elementStateModifiers[modifierKey] }; this.makeValid = function (el) { if (validElementStylingEnabled(el)) { this.getDomModifier(el).makeValid(el) } else { this.makeDefault(el) } }; this.makeInvalid = function (el, errorMsg) { if (invalidElementStylingEnabled(el)) { this.getDomModifier(el).makeInvalid(el, errorMsg) } else { this.makeDefault(el) } }; this.makeDefault = function (el) { var dm = this.getDomModifier(el); if (dm.makeDefault) { dm.makeDefault(el) } }; this.defaultFormValidationOptions = { forceValidation: false, disabled: false, validateNonVisibleControls: false, removeExternalValidationErrorsOnSubmit: true }; this.$get = [function () { return this }] }]) }(angular)); (function (angular) { angular.module("autoValidate").factory("bootstrap3ElementModifier", ["$log", function ($log) { var reset = function (el) { angular.forEach(el.find("span"), function (spanEl) { spanEl = angular.element(spanEl); if (spanEl.hasClass("error-msg") || spanEl.hasClass("form-control-feedback") || spanEl.hasClass("control-feedback")) { spanEl.remove() } }); el.removeClass("has-success has-error has-feedback") }, findWithClassElementAsc = function (el, klass) { var returnEl, parent = el; for (var i = 0; i <= 10; i += 1) { if (parent !== undefined && parent.hasClass(klass)) { returnEl = parent; break } else { if (parent !== undefined) { parent = parent.parent() } } } return returnEl }, findWithClassElementDesc = function (el, klass) { var child; for (var i = 0; i < el.children.length; i += 1) { child = el.children[i]; if (child !== undefined && angular.element(child).hasClass(klass)) { break } else { if (child.children !== undefined) { child = findWithClassElementDesc(child, klass); if (child.length > 0) { break } } } } return angular.element(child) }, findFormGroupElement = function (el) { return el.parent() }, findInputGroupElement = function (el) { return findWithClassElementDesc(el, "input-group") }, insertAfter = function (referenceNode, newNode) { referenceNode[0].parentNode.insertBefore(newNode[0], referenceNode[0].nextSibling) }, addValidationStateIcons = false, enableValidationStateIcons = function (enable) { addValidationStateIcons = enable }, makeValid = function (el) { var frmGroupEl = findFormGroupElement(el), inputGroupEl; if (frmGroupEl) { reset(frmGroupEl); inputGroupEl = findInputGroupElement(frmGroupEl[0]); frmGroupEl.addClass("has-success " + (inputGroupEl.length > 0 ? "" : "")); if (addValidationStateIcons) { var iconElText = '<span class="glyphicon glyphicon-ok form-control-feedback"></span>'; if (inputGroupEl.length > 0) { iconElText = iconElText.replace("form-", ""); iconElText = '<span class="input-group-addon control-feedback">' + iconElText + "</span" } insertAfter(el, angular.element(iconElText)) } } else { $log.error("Angular-auto-validate: invalid bs3 form structure elements must be wrapped by a form-group class") } }, makeInvalid = function (el, errorMsg) { var frmGroupEl = findFormGroupElement(el), helpTextEl = angular.element('<span class="help-block has-error error-msg" data-toggle="tooltip" data-container="body" data-placement="right" title="" data-original-title="' + errorMsg + '">' + " * " + "</span>"), inputGroupEl; if (frmGroupEl) { reset(frmGroupEl); inputGroupEl = findInputGroupElement(frmGroupEl[0]); frmGroupEl.addClass("has-error " + (inputGroupEl.length > 0 ? "" : "")); insertAfter(inputGroupEl.length > 0 ? inputGroupEl : el, helpTextEl); if (addValidationStateIcons) { var iconElText = '<span class="glyphicon glyphicon-remove form-control-feedback"></span>'; if (inputGroupEl.length > 0) { iconElText = iconElText.replace("form-", ""); iconElText = '<span class="input-group-addon control-feedback">' + iconElText + "</span" } insertAfter(el, angular.element(iconElText)) } } else { $log.error("Angular-auto-validate: invalid bs3 form structure elements must be wrapped by a form-group class") } $(helpTextEl).tooltip() }, makeDefault = function (el) { var frmGroupEl = findFormGroupElement(el); if (frmGroupEl) { reset(frmGroupEl) } else { $log.error("Angular-auto-validate: invalid bs3 form structure elements must be wrapped by a form-group class") } }; return { makeValid: makeValid, makeInvalid: makeInvalid, makeDefault: makeDefault, enableValidationStateIcons: enableValidationStateIcons, key: "bs3" } }]) }(angular)); (function (angular) { angular.module("autoValidate").factory("debounce", ["$timeout", function ($timeout) { var debounce = function (fn, timeout, apply) { timeout = angular.isUndefined(timeout) ? 0 : timeout; apply = angular.isUndefined(apply) ? true : apply; var nthCall = 0; return function () { var that = this; var argz = arguments; nthCall += 1; var later = (function (version) { return function () { if (version === nthCall) { return fn.apply(that, argz) } } })(nthCall); return $timeout(later, timeout, apply) } }; return { debounce: debounce } }]) }(angular)); (function (String, angular) { if (!("format" in String.prototype)) { String.prototype.format = function () { var args = arguments; return this.replace(/{(\d+)}/g, function (match, number) { return typeof args[number] !== undefined ? args[number] : match }) } } angular.autoValidate = angular.autoValidate || { errorMessages: {} }; angular.autoValidate.errorMessages["en-us"] = angular.autoValidate.errorMessages["en-gb"] = { defaultMsg: "Please add error message for {0}", email: "Please enter a valid email address", minlength: "Please enter at least {0} characters", maxlength: "You have entered more than the maximum {0} characters", min: "Please enter the minimum number of {0}", max: "Please enter the maximum number of {0}", required: "This field is required", date: "Please enter a valid date", pattern: "Please ensure the entered information adheres to this pattern {0}", number: "Please enter a valid number", url: "Please enter a valid URL in the format of http(s)://www.google.com" }; angular.module("autoValidate").factory("defaultErrorMessageResolver", ["$q", "$http", function ($q, $http) { var currentCulture = "en-gb", i18nFileRootPath = "js/angular-auto-validate/dist/lang", cultureRetrievalPromise, loadRemoteCulture = function (culture) { cultureRetrievalPromise = $http.get("{0}/auto-validate_{1}.json".format(i18nFileRootPath, culture.toLowerCase())); return cultureRetrievalPromise }, setI18nFileRootPath = function (rootPath) { i18nFileRootPath = rootPath }, setCulture = function (culture, cultureLoadingFn) { var defer = $q.defer(); cultureLoadingFn = cultureLoadingFn || loadRemoteCulture; currentCulture = culture.toLowerCase(); if (angular.autoValidate.errorMessages[currentCulture] === undefined) { cultureRetrievalPromise = cultureLoadingFn(culture); cultureRetrievalPromise.then(function (response) { cultureRetrievalPromise = undefined; angular.autoValidate.errorMessages[currentCulture] = response.data; defer.resolve(angular.autoValidate.errorMessages[currentCulture]) }, function (err) { angular.autoValidate.errorMessages[currentCulture] = { defaultMsg: "Loading culture failed!" }; cultureRetrievalPromise = null; defer.reject(err) }) } else { defer.resolve(angular.autoValidate.errorMessages[currentCulture]) } return defer.promise }, getErrorMessages = function (culture) { var defer = $q.defer(); culture = culture === undefined ? currentCulture : culture.toLowerCase(); if (cultureRetrievalPromise !== undefined) { cultureRetrievalPromise.then(function () { defer.resolve(angular.autoValidate.errorMessages[culture]) }, function (err) { defer.reject(err) }) } else { defer.resolve(angular.autoValidate.errorMessages[culture]) } return defer.promise }, getMessageTypeOverride = function (errorType, el) { var overrideKey; if (el) { errorType += "-err-type"; overrideKey = el.attr("ng-" + errorType); if (overrideKey === undefined) { overrideKey = el.attr("data-ng-" + errorType) || el.attr(errorType) } if (overrideKey) { overrideKey = overrideKey.replace(/[\W]/g, "") } } return overrideKey }, resolve = function (errorType, el) { var defer = $q.defer(), errMsg, parameters = [], parameter, messageTypeOverride; if (cultureRetrievalPromise !== undefined) { cultureRetrievalPromise.then(function () { resolve(errorType, el).then(function (msg) { defer.resolve(msg) }) }) } else { errMsg = angular.autoValidate.errorMessages[currentCulture][errorType]; messageTypeOverride = getMessageTypeOverride(errorType, el); if (messageTypeOverride) { errMsg = angular.autoValidate.errorMessages[currentCulture][messageTypeOverride] } if (errMsg === undefined) { errMsg = angular.autoValidate.errorMessages[currentCulture].defaultMsg.format(errorType) } if (el && el.attr) { try { parameter = el.attr("ng-" + errorType); if (parameter === undefined) { parameter = el.attr("data-ng-" + errorType) || el.attr(errorType) } parameters.push(parameter || ""); errMsg = errMsg.format(parameters) } catch (e) { } } defer.resolve(errMsg) } return defer.promise }; return { setI18nFileRootPath: setI18nFileRootPath, setCulture: setCulture, getErrorMessages: getErrorMessages, resolve: resolve } }]) }(String, angular)); (function (angular) { angular.module("autoValidate").factory("foundation5ElementModifier", [function () { var reset = function (el, inputEl) { angular.forEach(el.find("small"), function (smallEl) { if (angular.element(smallEl).hasClass("error")) { angular.element(smallEl).remove() } }); inputEl.removeClass("error") }, findParentColumn = function (el) { var parent = el; for (var i = 0; i <= 3; i += 1) { if (parent !== undefined && parent.hasClass("columns")) { break } else { if (parent !== undefined) { parent = parent.parent() } } } return parent }, makeValid = function (el) { var parentColumn = findParentColumn(el); reset(parentColumn && parentColumn.length > 0 ? parentColumn : el, el) }, makeInvalid = function (el, errorMsg) { var parentColumn = findParentColumn(el), helpTextEl; reset(parentColumn || el, el); el.addClass("error"); if (parentColumn) { helpTextEl = angular.element('<small class="error">' + errorMsg + "</small>"); parentColumn.append(helpTextEl) } }, makeDefault = function (el) { makeValid(el) }; return { makeValid: makeValid, makeInvalid: makeInvalid, makeDefault: makeDefault, key: "foundation5" } }]) }(angular)); (function (angular) { angular.module("autoValidate").factory("elementUtils", [function () { var isElementVisible = function (el) { return el[0].offsetWidth > 0 && el[0].offsetHeight > 0 }; return { isElementVisible: isElementVisible } }]); angular.module("autoValidate").factory("validationManager", ["validator", "elementUtils", function (validator, elementUtils) { var elementTypesToValidate = ["input", "textarea", "select", "form"], elementIsVisible = function (el) { return elementUtils.isElementVisible(el) }, getFormOptions = function (el) { var frmCtrl = angular.element(el).controller("form"); return frmCtrl !== undefined && frmCtrl !== null ? frmCtrl.autoValidateFormOptions : validator.defaultFormValidationOptions }, shouldValidateElement = function (el, formOptions) { var result = el && el.length > 0 && (elementIsVisible(el) || formOptions.validateNonVisibleControls) && (elementTypesToValidate.indexOf(el[0].nodeName.toLowerCase()) > -1 || el[0].hasAttribute("register-custom-form-control")); return result }, validateElement = function (modelCtrl, el, options) { var isValid = true, frmOptions = options || getFormOptions(el), needsValidation = modelCtrl.$pristine === false || frmOptions.forceValidation, errorType, findErrorType = function ($errors) { var keepGoing = true, errorTypeToReturn; angular.forEach($errors, function (status, errortype) { if (keepGoing && status) { keepGoing = false; errorTypeToReturn = errortype } }); return errorTypeToReturn }; if (frmOptions.disabled === false) { if ((frmOptions.forceValidation || (shouldValidateElement(el, frmOptions) && modelCtrl && needsValidation))) { isValid = !modelCtrl.$invalid; if (frmOptions.removeExternalValidationErrorsOnSubmit && modelCtrl.removeAllExternalValidation) { modelCtrl.removeAllExternalValidation() } if (isValid) { validator.makeValid(el) } else { errorType = findErrorType(modelCtrl.$errors || modelCtrl.$error); if (errorType === undefined) { isValid = true } else { validator.getErrorMessage(errorType, el).then(function (errorMsg) { validator.makeInvalid(el, errorMsg) }) } } } } return isValid }, resetElement = function (element) { validator.makeDefault(element) }, resetForm = function (frmElement) { angular.forEach((frmElement[0].all || frmElement[0].elements) || frmElement[0], function (element) { var controller, ctrlElement = angular.element(element); controller = ctrlElement.controller("ngModel"); if (controller !== undefined) { if (ctrlElement[0].nodeName.toLowerCase() === "form") { resetForm(ctrlElement) } else { controller.$setPristine() } } }) }, validateForm = function (frmElement) { var frmValid = true, frmCtrl = frmElement ? angular.element(frmElement).controller("form") : undefined, processElement = function (ctrlElement, force, formOptions) { var controller, isValid, ctrlFormOptions, originalForceValue; ctrlElement = angular.element(ctrlElement); controller = ctrlElement.controller("ngModel"); if (controller !== undefined && (force || shouldValidateElement(ctrlElement, formOptions))) { if (ctrlElement[0].nodeName.toLowerCase() === "form") { validateForm(ctrlElement) } else { ctrlFormOptions = getFormOptions(ctrlElement); originalForceValue = ctrlFormOptions.forceValidation; ctrlFormOptions.forceValidation = force; try { isValid = validateElement(controller, ctrlElement, ctrlFormOptions); frmValid = frmValid && isValid } finally { ctrlFormOptions.forceValidation = originalForceValue } } } }, clonedOptions; if (frmElement === undefined || (frmCtrl !== undefined && frmCtrl.autoValidateFormOptions.disabled)) { return frmElement !== undefined } clonedOptions = angular.copy(frmCtrl.autoValidateFormOptions); clonedOptions.forceValidation = true; angular.forEach((frmElement[0].all || frmElement[0].elements) || frmElement[0], function (ctrlElement) { processElement(ctrlElement, true, clonedOptions) }); if (frmElement[0].customHTMLFormControlsCollection) { angular.forEach(frmElement[0].customHTMLFormControlsCollection, function (ctrlElement) { processElement(ctrlElement, true, clonedOptions) }) } return frmValid }, setElementValidationError = function (element, errorMsgKey, errorMsg) { if (errorMsgKey) { validator.getErrorMessage(errorMsgKey, element).then(function (msg) { validator.makeInvalid(element, msg) }) } else { validator.makeInvalid(element, errorMsg) } }; return { setElementValidationError: setElementValidationError, validateElement: validateElement, validateForm: validateForm, resetElement: resetElement, resetForm: resetForm } }]) }(angular)); (function (angular) { function parseBooleanAttributeValue(val) { return val !== undefined && val !== "false" } function parseOptions(ctrl, validator, attrs) { var opts = ctrl.autoValidateFormOptions = ctrl.autoValidateFormOptions || angular.copy(validator.defaultFormValidationOptions); opts.forceValidation = false; opts.disabled = !validator.isEnabled() || parseBooleanAttributeValue(attrs.disableDynamicValidation); opts.validateNonVisibleControls = parseBooleanAttributeValue(attrs.validateNonVisibleControls); opts.removeExternalValidationErrorsOnSubmit = attrs.removeExternalValidationErrorsOnSubmit === undefined ? true : parseBooleanAttributeValue(attrs.removeExternalValidationErrorsOnSubmit); if (validator.isEnabled() === false && attrs.disableDynamicValidation === "false") { opts.disabled = false } } angular.module("autoValidate").directive("form", ["validator", function (validator) { return { restrict: "E", require: "form", priority: 9999, compile: function () { return { pre: function (scope, element, attrs, ctrl) { parseOptions(ctrl, validator, attrs) } } } } }]); angular.module("autoValidate").directive("ngForm", ["validator", function (validator) { return { restrict: "EA", require: "form", priority: 9999, compile: function () { return { pre: function (scope, element, attrs, ctrl) { parseOptions(ctrl, validator, attrs) } } } } }]) }(angular)); (function (angular) { angular.module("autoValidate").directive("form", ["validationManager", function (validationManager) { return { restrict: "E", link: function (scope, el) { var formController = el.controller("form"); if (formController !== undefined && formController.autoValidateFormOptions && formController.autoValidateFormOptions.disabled === false) { el.on("reset", function () { validationManager.resetForm(el); if (formController.$setPristine) { formController.$setPristine() } if (formController.$setUntouched) { formController.$setUntouched() } }); scope.$on("$destroy", function () { el.off("reset") }) } } } }]) }(angular)); (function (angular) { angular.module("autoValidate").directive("registerCustomFormControl", [function () { var findParentForm = function (el) { var parent = el; for (var i = 0; i <= 50; i += 1) { if (parent !== undefined && parent.nodeName.toLowerCase() === "form") { break } else { if (parent !== undefined) { parent = angular.element(parent).parent()[0] } } } return parent }; return { restrict: "A", link: function (scope, element) { var frmEl = findParentForm(element.parent()[0]); if (frmEl) { frmEl.customHTMLFormControlsCollection = frmEl.customHTMLFormControlsCollection || []; frmEl.customHTMLFormControlsCollection.push(element[0]) } } } }]) }(angular)); (function (angular) { function SubmitDecorator($delegate, $parse, validationManager) { $delegate[0].compile = function ($element, attrs) { var fn = $parse(attrs.ngSubmit), force = attrs.ngSubmitForce === "true"; return function (scope, element) { var formController = element.controller("form"), resetListenerOffFn; function handlerFn(event) { scope.$apply(function () { if (formController !== undefined && formController !== null && formController.autoValidateFormOptions && formController.autoValidateFormOptions.disabled === true) { fn(scope, { $event: event }) } else { if (validationManager.validateForm(element) || force === true) { fn(scope, { $event: event }) } } }) } function resetFormFn() { if (element[0].reset) { element[0].reset() } else { validationManager.resetForm(element) } } if (formController && formController.autoValidateFormOptions) { formController.autoValidateFormOptions.resetForm = resetFormFn; if (formController.$name !== undefined && formController.$name !== "") { resetListenerOffFn = scope.$on("form:" + formController.$name + ":reset", resetFormFn) } } element.on("submit", handlerFn); scope.$on("$destroy", function () { element.off("submit", handlerFn); if (resetListenerOffFn) { resetListenerOffFn() } }) } }; return $delegate } SubmitDecorator.$inject = ["$delegate", "$parse", "validationManager"]; function ProviderFn($provide) { $provide.decorator("ngSubmitDirective", SubmitDecorator) } ProviderFn.$inject = ["$provide"]; angular.module("autoValidate").config(ProviderFn) }(angular)); (function (angular) { angular.module("autoValidate").config(["$provide", function ($provide) { $provide.decorator("ngModelDirective", ["$timeout", "$delegate", "validationManager", "debounce", function ($timeout, $delegate, validationManager, debounce) { var directive = $delegate[0], link = directive.link || directive.compile; directive.compile = function (el) { return function (scope, element, attrs, ctrls) { var ngModelCtrl = ctrls[0], frmCtrl = ctrls[1], supportsNgModelOptions = angular.version.major >= 1 && angular.version.minor >= 3, ngModelOptions = attrs.ngModelOptions === undefined ? undefined : scope.$eval(attrs.ngModelOptions), setValidity = ngModelCtrl.$setValidity, setPristine = ngModelCtrl.$setPristine, setValidationState = debounce.debounce(function () { var validateOptions = frmCtrl !== undefined && frmCtrl !== null ? frmCtrl.autoValidateFormOptions : undefined; validationManager.validateElement(ngModelCtrl, element, validateOptions) }, 100); if (supportsNgModelOptions && angular.isFunction(link)) { link = link(el) } if (link.pre) { link.pre.apply(this, arguments); ngModelOptions = ngModelCtrl.$options === undefined ? undefined : ngModelCtrl.$options } if (attrs.formnovalidate === undefined && (frmCtrl !== undefined && frmCtrl !== null && frmCtrl.autoValidateFormOptions && frmCtrl.autoValidateFormOptions.disabled === false)) { if (supportsNgModelOptions || ngModelOptions === undefined || ngModelOptions.updateOn === undefined || ngModelOptions.updateOn === "") { ngModelCtrl.$setValidity = function (validationErrorKey, isValid) { setValidity.call(ngModelCtrl, validationErrorKey, isValid); setValidationState() } } else { element.on(ngModelOptions.updateOn, function () { setValidationState() }); scope.$on("$destroy", function () { element.off(ngModelOptions.updateOn) }) } ngModelCtrl.$setPristine = function () { setPristine.call(ngModelCtrl); validationManager.resetElement(element) }; ngModelCtrl.autoValidated = true } if (link.post) { link.post.apply(this, arguments) } else { link.apply(this, arguments) } ngModelCtrl.setExternalValidation = function (errorMsgKey, errorMessage, addToModelErrors) { if (addToModelErrors) { var collection = ngModelCtrl.$error || ngModelCtrl.$errors; collection[errorMsgKey] = false } ngModelCtrl.externalErrors = ngModelCtrl.externalErrors || {}; ngModelCtrl.externalErrors[errorMsgKey] = false; validationManager.setElementValidationError(element, errorMsgKey, errorMessage) }; ngModelCtrl.removeExternalValidation = function (errorMsgKey, addToModelErrors) { if (addToModelErrors) { var collection = ngModelCtrl.$error || ngModelCtrl.$errors; delete collection[errorMsgKey] } if (ngModelCtrl.externalErrors) { delete ngModelCtrl.externalErrors[errorMsgKey] } validationManager.resetElement(element) }; ngModelCtrl.removeAllExternalValidation = function () { if (ngModelCtrl.externalErrors) { var errorCollection = ngModelCtrl.$error || ngModelCtrl.$errors; angular.forEach(ngModelCtrl.externalErrors, function (value, key) { delete errorCollection[key] }); ngModelCtrl.externalErrors = {}; validationManager.resetElement(element) } }; if (frmCtrl) { frmCtrl.setExternalValidation = function (modelProperty, errorMsgKey, errorMessageOverride, addToModelErrors) { var success = false; if (frmCtrl[modelProperty]) { frmCtrl[modelProperty].setExternalValidation(errorMsgKey, errorMessageOverride, addToModelErrors); success = true } return success }; frmCtrl.removeExternalValidation = function (modelProperty, errorMsgKey, errorMessageOverride, addToModelErrors) { var success = false; if (frmCtrl[modelProperty]) { frmCtrl[modelProperty].removeExternalValidation(errorMsgKey, addToModelErrors); success = true } return success } } } }; return $delegate }]) }]) }(angular)); (function (angular) { angular.module("autoValidate").run(["validator", "defaultErrorMessageResolver", "bootstrap3ElementModifier", "foundation5ElementModifier", function (validator, defaultErrorMessageResolver, bootstrap3ElementModifier, foundation5ElementModifier) { validator.setErrorMessageResolver(defaultErrorMessageResolver.resolve); validator.registerDomModifier(bootstrap3ElementModifier.key, bootstrap3ElementModifier); validator.registerDomModifier(foundation5ElementModifier.key, foundation5ElementModifier); validator.setDefaultElementModifier(bootstrap3ElementModifier.key) }]) }(angular));